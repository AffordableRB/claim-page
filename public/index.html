// api/verify.js - Enhanced with Better Debugging and Multiple Search Methods
import { initializeApp, getApps } from 'firebase/app';
import { getFirestore, collection, addDoc, serverTimestamp, connectFirestoreEmulator } from 'firebase/firestore';
import crypto from 'crypto';

const DEBUG_MODE = process.env.NODE_ENV === 'development';

// Initialize Firebase (only once per cold start)
let app;
let db;
let isInitialized = false;

function initFirebase() {
  if (!isInitialized) {
    console.log('üî• Initializing Firebase...');
    
    const requiredEnvVars = [
      'FIREBASE_API_KEY',
      'FIREBASE_AUTH_DOMAIN', 
      'FIREBASE_PROJECT_ID',
      'FIREBASE_STORAGE_BUCKET',
      'FIREBASE_MESSAGING_SENDER_ID',
      'FIREBASE_APP_ID'
    ];
    
    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
    if (missingVars.length > 0) {
      throw new Error(`Missing Firebase environment variables: ${missingVars.join(', ')}`);
    }

    const firebaseConfig = {
      apiKey: process.env.FIREBASE_API_KEY,
      authDomain: process.env.FIREBASE_AUTH_DOMAIN,
      projectId: process.env.FIREBASE_PROJECT_ID,
      storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.FIREBASE_APP_ID
    };
    
    if (getApps().length === 0) {
      app = initializeApp(firebaseConfig);
    } else {
      app = getApps()[0];
    }
    
    db = getFirestore(app);
    
    if (DEBUG_MODE && process.env.FIRESTORE_EMULATOR_HOST) {
      connectFirestoreEmulator(db, 'localhost', 8080);
    }
    
    isInitialized = true;
    console.log('‚úÖ Firebase initialized successfully');
  }
  
  return db;
}

// DEBUG FUNCTION FOR SHOPIFY
async function debugShopifyConnection() {
  console.log('üîß SHOPIFY DEBUG TEST STARTING...');
  
  const shopDomain = process.env.SHOPIFY_SHOP_DOMAIN;
  const accessToken = process.env.SHOPIFY_ACCESS_TOKEN;
  const apiVersion = process.env.SHOPIFY_API_VERSION || '2024-01';
  
  const debugInfo = {
    environment: {
      shopDomain: shopDomain ? `${shopDomain.substring(0, 8)}***` : 'MISSING',
      hasAccessToken: !!accessToken,
      tokenLength: accessToken?.length || 0,
      tokenStart: accessToken ? `${accessToken.substring(0, 8)}***` : 'MISSING',
      apiVersion
    },
    tests: {}
  };

  // Test 1: Basic shop info
  try {
    console.log('Test 1: Shop connectivity...');
    const shopUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/shop.json`;
    const shopResponse = await fetch(shopUrl, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json'
      }
    });
    
    debugInfo.tests.shopConnectivity = {
      status: shopResponse.status,
      ok: shopResponse.ok,
      statusText: shopResponse.statusText,
      url: shopUrl.replace(accessToken, 'TOKEN_HIDDEN')
    };
    
    if (shopResponse.ok) {
      const shopData = await shopResponse.json();
      debugInfo.tests.shopConnectivity.shopName = shopData.shop?.name;
      debugInfo.tests.shopConnectivity.domain = shopData.shop?.domain;
      debugInfo.tests.shopConnectivity.email = shopData.shop?.email;
    } else {
      const errorText = await shopResponse.text();
      debugInfo.tests.shopConnectivity.error = errorText.substring(0, 200);
    }
  } catch (error) {
    debugInfo.tests.shopConnectivity = { error: error.message };
  }

  // Test 2: List recent orders
  try {
    console.log('Test 2: Recent orders...');
    const ordersUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/orders.json?limit=10&status=any&fields=id,name,email,order_number,created_at,financial_status`;
    const ordersResponse = await fetch(ordersUrl, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json'
      }
    });
    
    debugInfo.tests.recentOrders = {
      status: ordersResponse.status,
      ok: ordersResponse.ok,
      statusText: ordersResponse.statusText
    };
    
    if (ordersResponse.ok) {
      const ordersData = await ordersResponse.json();
      debugInfo.tests.recentOrders.count = ordersData.orders?.length || 0;
      debugInfo.tests.recentOrders.orders = ordersData.orders?.map(order => ({
        name: order.name,
        email: order.email?.substring(0, 5) + '***',
        order_number: order.order_number,
        created_at: order.created_at,
        financial_status: order.financial_status
      })) || [];
    } else {
      const errorText = await ordersResponse.text();
      debugInfo.tests.recentOrders.error = errorText.substring(0, 200);
    }
  } catch (error) {
    debugInfo.tests.recentOrders = { error: error.message };
  }

  // Test 3: Search for order 1014 specifically
  try {
    console.log('Test 3: Searching for order 1014...');
    const searchQueries = ['1014', '#1014', 'AG-1014', 'AF1014'];
    
    debugInfo.tests.orderSearch = {};
    
    for (const query of searchQueries) {
      const searchUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/orders.json?name=${encodeURIComponent(query)}&limit=5&status=any`;
      const searchResponse = await fetch(searchUrl, {
        headers: {
          'X-Shopify-Access-Token': accessToken,
          'Content-Type': 'application/json'
        }
      });
      
      debugInfo.tests.orderSearch[query] = {
        status: searchResponse.status,
        ok: searchResponse.ok,
        url: searchUrl.replace(accessToken, 'TOKEN_HIDDEN')
      };
      
      if (searchResponse.ok) {
        const searchData = await searchResponse.json();
        debugInfo.tests.orderSearch[query].count = searchData.orders?.length || 0;
        debugInfo.tests.orderSearch[query].orders = searchData.orders?.map(order => ({
          name: order.name,
          email: order.email?.substring(0, 5) + '***',
          order_number: order.order_number
        })) || [];
      } else {
        const errorText = await searchResponse.text();
        debugInfo.tests.orderSearch[query].error = errorText.substring(0, 100);
      }
    }
  } catch (error) {
    debugInfo.tests.orderSearch = { error: error.message };
  }

  // Test 4: Check permissions
  try {
    console.log('Test 4: API permissions...');
    const permUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/orders.json?limit=1&fields=id,name`;
    const permResponse = await fetch(permUrl, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json'
      }
    });
    
    debugInfo.tests.permissions = {
      status: permResponse.status,
      ok: permResponse.ok,
      statusText: permResponse.statusText
    };
    
    if (!permResponse.ok) {
      const errorText = await permResponse.text();
      debugInfo.tests.permissions.error = errorText;
    }
    
  } catch (error) {
    debugInfo.tests.permissions = { error: error.message };
  }

  console.log('üîç DEBUG RESULTS:', JSON.stringify(debugInfo, null, 2));
  return debugInfo;
}

// ENHANCED ORDER SEARCH FUNCTION
async function findShopifyOrder(orderNumber, email) {
  const shopDomain = process.env.SHOPIFY_SHOP_DOMAIN;
  const accessToken = process.env.SHOPIFY_ACCESS_TOKEN;
  const apiVersion = process.env.SHOPIFY_API_VERSION || '2024-01';
  
  console.log('üîç Shopify Configuration Check:', {
    shopDomain: shopDomain ? `${shopDomain.substring(0, 5)}...` : 'MISSING',
    hasAccessToken: !!accessToken,
    tokenLength: accessToken?.length || 0,
    apiVersion,
    originalOrderNumber: orderNumber,
    email
  });

  // Enhanced search queries with more variations
  const searchQueries = [
    orderNumber,
    orderNumber.replace(/^#/, ''),
    `#${orderNumber.replace(/^#/, '')}`,
    orderNumber.replace(/^AG-/, ''),
    `AG-${orderNumber.replace(/^(AG-|#)/, '')}`,
    orderNumber.replace(/^AF/, ''),
    `AF${orderNumber.replace(/^(AF|AG-|#)/, '')}`,
    // Add order number without prefixes
    orderNumber.replace(/^(AG-|AF|#)/, ''),
    // Try with leading zeros
    orderNumber.replace(/^(AG-|AF|#)/, '').padStart(4, '0'),
    `AG-${orderNumber.replace(/^(AG-|AF|#)/, '').padStart(4, '0')}`
  ];

  const uniqueSearchQueries = [...new Set(searchQueries)];
  console.log('üìã Search queries to try:', uniqueSearchQueries);

  let foundOrderWithWrongEmail = null;
  let lastResponse = null;

  // Method 1: Search by name (most common)
  for (const query of uniqueSearchQueries) {
    try {
      console.log(`üîé Searching by name: "${query}"`);
      
      const nameSearchUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/orders.json?name=${encodeURIComponent(query)}&limit=10&status=any`;
      
      console.log('üì° Request URL:', nameSearchUrl.replace(accessToken, 'TOKEN_HIDDEN'));
      
      const response = await fetch(nameSearchUrl, {
        headers: {
          'X-Shopify-Access-Token': accessToken,
          'Content-Type': 'application/json'
        }
      });

      lastResponse = {
        status: response.status,
        statusText: response.statusText,
        query: query
      };

      console.log(`üìä Response for "${query}":`, {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`‚ùå API Error for query "${query}":`, {
          status: response.status,
          statusText: response.statusText,
          error: errorText.substring(0, 200)
        });
        continue;
      }

      const data = await response.json();
      console.log(`üì¶ Orders found for "${query}":`, data.orders?.length || 0);
      
      if (data.orders && data.orders.length > 0) {
        data.orders.forEach((order, index) => {
          console.log(`  Order ${index + 1}: ${order.name} | ${order.email} | Status: ${order.financial_status}`);
        });

        const order = data.orders[0];
        
        if (order.email && order.email.toLowerCase() === email.toLowerCase()) {
          console.log(`‚úÖ PERFECT MATCH: ${order.name} with email ${order.email}`);
          return { order, emailMatch: true };
        } else {
          console.log(`‚ö†Ô∏è Order found but email mismatch: ${order.email} vs ${email}`);
          foundOrderWithWrongEmail = order;
        }
      }
      
    } catch (error) {
      console.error(`üí• Error searching for order "${query}":`, error.message);
      continue;
    }
  }

  // Method 2: Search by order_number field
  console.log('üîç Trying order_number search...');
  const cleanOrderNum = orderNumber.replace(/^(AG-|AF|#)/, '');
  
  try {
    const orderNumUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/orders.json?limit=50&status=any&fields=id,name,email,order_number,financial_status`;
    
    const response = await fetch(orderNumUrl, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      const data = await response.json();
      console.log(`üì¶ Found ${data.orders?.length || 0} recent orders to check`);
      
      if (data.orders && data.orders.length > 0) {
        const matchingOrder = data.orders.find(order => {
          const orderMatches = uniqueSearchQueries.some(query => {
            return order.name === query || 
                   order.order_number?.toString() === cleanOrderNum ||
                   order.order_number?.toString() === query;
          });
          return orderMatches && order.email?.toLowerCase() === email.toLowerCase();
        });
        
        if (matchingOrder) {
          console.log(`‚úÖ FOUND via order_number search: ${matchingOrder.name}`);
          return { order: matchingOrder, emailMatch: true };
        }
      }
    }
  } catch (error) {
    console.error('‚ùå Order number search failed:', error.message);
  }

  // Method 3: Search by email first, then filter
  console.log('üìß Trying email-first search...');
  try {
    const emailSearchUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/orders.json?email=${encodeURIComponent(email)}&limit=50&status=any`;
    
    const response = await fetch(emailSearchUrl, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      const data = await response.json();
      console.log(`üì¨ Found ${data.orders?.length || 0} orders for email ${email}`);
      
      if (data.orders && data.orders.length > 0) {
        data.orders.forEach((order, index) => {
          console.log(`  Email Order ${index + 1}: ${order.name} | Created: ${order.created_at}`);
        });

        const matchingOrder = data.orders.find(order => {
          return uniqueSearchQueries.some(query => {
            return order.name === query || 
                   order.order_number?.toString() === cleanOrderNum ||
                   (order.name && order.name.includes(cleanOrderNum));
          });
        });
        
        if (matchingOrder) {
          console.log(`‚úÖ FOUND via email search: ${matchingOrder.name}`);
          return { order: matchingOrder, emailMatch: true };
        }
      }
    }
  } catch (error) {
    console.error('‚ùå Email search failed:', error.message);
  }

  // Method 4: Try GraphQL API as fallback
  console.log('üîÑ Trying GraphQL API as last resort...');
  try {
    const graphqlQuery = `
      query getOrders($query: String!) {
        orders(first: 10, query: $query) {
          nodes {
            id
            name
            email
            legacyResourceId
            financialStatus
            customer {
              firstName
              lastName
            }
            totalPriceSet {
              shopMoney {
                amount
                currencyCode
              }
            }
            createdAt
          }
        }
      }
    `;

    const graphqlUrl = `https://${shopDomain}.myshopify.com/admin/api/${apiVersion}/graphql.json`;
    
    for (const query of uniqueSearchQueries.slice(0, 3)) { // Try only first 3 to avoid rate limits
      const searchQuery = `name:${query} OR email:${email}`;
      
      const response = await fetch(graphqlUrl, {
        method: 'POST',
        headers: {
          'X-Shopify-Access-Token': accessToken,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: graphqlQuery,
          variables: { query: searchQuery }
        })
      });

      if (response.ok) {
        const data = await response.json();
        console.log('üìà GraphQL response:', JSON.stringify(data, null, 2));
        
        if (data.data?.orders?.nodes?.length > 0) {
          const matchingOrder = data.data.orders.nodes.find(order => 
            order.name === query && order.email?.toLowerCase() === email.toLowerCase()
          );
          
          if (matchingOrder) {
            console.log(`‚úÖ FOUND via GraphQL: ${matchingOrder.name}`);
            // Convert GraphQL format to REST format
            const restOrder = {
              id: matchingOrder.legacyResourceId,
              name: matchingOrder.name,
              email: matchingOrder.email,
              financial_status: matchingOrder.financialStatus?.toLowerCase(),
              total_price: matchingOrder.totalPriceSet?.shopMoney?.amount,
              currency: matchingOrder.totalPriceSet?.shopMoney?.currencyCode,
              created_at: matchingOrder.createdAt,
              customer: {
                first_name: matchingOrder.customer?.firstName,
                last_name: matchingOrder.customer?.lastName
              }
            };
            return { order: restOrder, emailMatch: true };
          }
        }
      }
    }
  } catch (error) {
    console.error('‚ùå GraphQL search failed:', error.message);
  }

  // Final diagnostic info
  console.log('üîç FINAL DIAGNOSIS:', {
    lastResponseStatus: lastResponse?.status,
    lastResponseQuery: lastResponse?.query,
    foundOrderWithWrongEmail: !!foundOrderWithWrongEmail,
    wrongEmailOrderName: foundOrderWithWrongEmail?.name,
    wrongEmailOrderEmail: foundOrderWithWrongEmail?.email,
    searchedQueries: uniqueSearchQueries.length,
    shopDomain: `${shopDomain?.substring(0, 10)}...`,
    accessTokenPresent: !!accessToken
  });

  if (foundOrderWithWrongEmail) {
    return { order: foundOrderWithWrongEmail, emailMatch: false };
  }

  return null;
}

// ENHANCED ORDER VERIFICATION
async function handleOrderVerification(req, res, orderNumber, email) {
  console.log(`\nüîç === ENHANCED ORDER VERIFICATION START ===`);
  console.log(`Order: ${orderNumber} | Email: ${email}`);
  console.log(`Timestamp: ${new Date().toISOString()}`);
  
  // Input validation
  if (!orderNumber || !email) {
    console.log('‚ùå Missing required parameters');
    return res.status(400).json({ error: 'Order number and email are required' });
  }

  const cleanOrderNumber = orderNumber.trim();
  const cleanEmail = email.toLowerCase().trim();

  // Basic email format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(cleanEmail)) {
    console.log('‚ùå Invalid email format');
    return res.status(400).json({ error: 'Invalid email format' });
  }

  try {
    // Check environment variables more thoroughly
    const envCheck = {
      SHOPIFY_SHOP_DOMAIN: !!process.env.SHOPIFY_SHOP_DOMAIN,
      SHOPIFY_ACCESS_TOKEN: !!process.env.SHOPIFY_ACCESS_TOKEN,
      shopDomainValue: process.env.SHOPIFY_SHOP_DOMAIN?.substring(0, 10) + '...',
      tokenLength: process.env.SHOPIFY_ACCESS_TOKEN?.length
    };
    
    console.log('üîß Environment check:', envCheck);

    if (!process.env.SHOPIFY_SHOP_DOMAIN || !process.env.SHOPIFY_ACCESS_TOKEN) {
      console.error('‚ùå Missing Shopify credentials');
      return res.status(500).json({ 
        error: 'Server configuration error',
        details: 'Missing Shopify API credentials'
      });
    }

    // Test API connectivity first
    console.log('üß™ Testing Shopify API connectivity...');
    const testUrl = `https://${process.env.SHOPIFY_SHOP_DOMAIN}.myshopify.com/admin/api/2024-01/shop.json`;
    
    const testResponse = await fetch(testUrl, {
      headers: {
        'X-Shopify-Access-Token': process.env.SHOPIFY_ACCESS_TOKEN,
        'Content-Type': 'application/json'
      }
    });

    console.log('üîå API connectivity test:', {
      status: testResponse.status,
      statusText: testResponse.statusText,
      ok: testResponse.ok
    });

    if (!testResponse.ok) {
      const errorText = await testResponse.text();
      console.error('‚ùå Shopify API connectivity failed:', {
        status: testResponse.status,
        error: errorText.substring(0, 300)
      });
      
      if (testResponse.status === 401) {
        return res.status(500).json({ 
          error: 'Invalid Shopify API credentials',
          details: 'Please check your access token'
        });
      } else if (testResponse.status === 404) {
        return res.status(500).json({ 
          error: 'Invalid shop domain',
          details: 'Please check your shop domain configuration'
        });
      }
    } else {
      const shopData = await testResponse.json();
      console.log('‚úÖ Connected to shop:', shopData.shop?.name || 'Unknown Shop');
    }

    // Now search for the order
    const searchResult = await findShopifyOrder(cleanOrderNumber, cleanEmail);
    
    console.log('üîç Search result:', {
      found: !!searchResult,
      emailMatch: searchResult?.emailMatch,
      orderName: searchResult?.order?.name
    });
    
    if (!searchResult) {
      console.log('‚ùå No matching order found after all search methods');
      return res.status(404).json({ 
        error: 'Order not found',
        details: `No order found matching "${cleanOrderNumber}" for email "${cleanEmail}". Please check both values and try again.`,
        searchedVariations: [
          cleanOrderNumber,
          `#${cleanOrderNumber}`,
          `AG-${cleanOrderNumber.replace(/^(AG-|#)/, '')}`,
          cleanOrderNumber.replace(/^(AG-|#)/, '')
        ]
      });
    }

    // Check if order was found but email doesn't match
    if (!searchResult.emailMatch) {
      console.log('‚ùå Order found but email mismatch');
      return res.status(400).json({ 
        error: 'Email does not match the order number',
        details: `Order "${searchResult.order.name}" exists but is associated with email "${searchResult.order.email}", not "${cleanEmail}". Please check your email and try again.`
      });
    }

    const order = searchResult.order;

    // Validate order for delivery
    const validationResult = validateOrderForDelivery(order);
    if (!validationResult.valid) {
      console.log('‚ùå Order validation failed:', validationResult.reason);
      return res.status(400).json({ 
        error: validationResult.reason,
        details: validationResult.details 
      });
    }

    console.log('‚úÖ Order verification successful:', order.name);
    console.log(`=== VERIFICATION COMPLETE ===\n`);

    // Return successful verification
    return res.status(200).json({
      orderNumber: order.name,
      email: cleanEmail,
      orderId: order.id.toString(),
      customerName: `${order.customer?.first_name || ''} ${order.customer?.last_name || ''}`.trim(),
      items: formatOrderItems(order.line_items),
      total: order.total_price,
      currency: order.currency,
      orderDate: order.created_at,
      fulfilled: order.fulfillment_status === 'fulfilled',
      verified: true,
      source: 'shopify_rest_api',
      searchMethod: 'enhanced_search'
    });

  } catch (error) {
    console.error('üí• Order verification error:', {
      message: error.message,
      stack: error.stack?.substring(0, 500)
    });
    
    return res.status(500).json({ 
      error: 'Failed to verify order',
      message: 'Please try again in a moment',
      details: DEBUG_MODE ? error.message : 'Internal server error'
    });
  }
}

// FIRESTORE SAVE FUNCTION (unchanged)
async function saveToFirestore(deliveryData) {
  const startTime = Date.now();
  
  try {
    console.log('üî• Saving delivery data to Firestore...');
    
    const db = initFirebase();
    const registrationId = generateDeliveryId();
    
    const docData = {
      registrationId,
      timestamp: serverTimestamp(),
      createdAt: new Date().toISOString(),
      orderNumber: deliveryData.order?.orderNumber || 'N/A',
      email: deliveryData.order?.email || 'N/A',
      orderItems: deliveryData.order?.items || 'Digital Items',
      orderTotal: deliveryData.order?.total || 'N/A',
      orderCurrency: deliveryData.order?.currency || 'USD',
      orderId: deliveryData.order?.orderId || null,
      customerName: deliveryData.order?.customerName || null,
      robloxUsername: deliveryData.roblox?.username || 'N/A',
      robloxUserId: deliveryData.roblox?.userId?.toString() || 'N/A',
      robloxAvatarUrl: deliveryData.roblox?.avatar || null,
      status: 'pending_delivery',
      deliveryStaffAssigned: null,
      serverJoinTime: deliveryData.serverJoinTime || new Date().toISOString(),
      completedAt: null,
      processedBy: 'delivery_system_v2',
      source: 'affordable_garden_delivery',
      apiVersion: '2.1',
      userAgent: deliveryData.userAgent || null,
      stepCompletionTimes: deliveryData.stepCompletionTimes || null,
      totalProcessingTime: Date.now() - startTime
    };

    const docRef = await addDoc(collection(db, 'delivery_requests'), docData);
    const elapsed = Date.now() - startTime;
    
    console.log(`‚úÖ Successfully saved to Firestore in ${elapsed}ms:`, {
      registrationId: registrationId,
      firestoreId: docRef.id,
      collection: 'delivery_requests'
    });
    
    return {
      success: true,
      registrationId,
      firestoreId: docRef.id,
      collection: 'delivery_requests',
      timing: elapsed,
      docPath: `delivery_requests/${docRef.id}`
    };

  } catch (error) {
    const elapsed = Date.now() - startTime;
    console.error(`‚ùå Firestore save failed after ${elapsed}ms:`, error);
    throw error;
  }
}

async function handleDeliveryRegistration(req, res, deliveryData) {
  console.log('üì¶ Processing Delivery Registration with Firestore...');
  
  const startTime = Date.now();
  const REQUEST_TIMEOUT = 8000;
  
  try {
    if (!deliveryData.order || !deliveryData.roblox) {
      return res.status(400).json({ 
        error: 'Missing required delivery data',
        required: ['order', 'roblox'],
        received: {
          hasOrder: !!deliveryData.order,
          hasRoblox: !!deliveryData.roblox
        }
      });
    }

    if (!deliveryData.order.orderNumber || !deliveryData.order.email) {
      return res.status(400).json({
        error: 'Invalid order data - missing orderNumber or email'
      });
    }

    if (!deliveryData.roblox.username || !deliveryData.roblox.userId) {
      return res.status(400).json({
        error: 'Invalid Roblox data - missing username or userId'
      });
    }

    deliveryData.userAgent = req.headers['user-agent'];
    
    const firestorePromise = saveToFirestore(deliveryData);
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error('Firestore operation timed out'));
      }, REQUEST_TIMEOUT);
    });
    
    let firestoreResult;
    try {
      firestoreResult = await Promise.race([firestorePromise, timeoutPromise]);
    } catch (timeoutError) {
      const elapsed = Date.now() - startTime;
      const fallbackId = generateDeliveryId();
      
      return res.status(202).json({
        success: false,
        message: 'Delivery request received (saving in background)',
        registrationId: fallbackId,
        warning: 'Save operation timed out but request was processed',
        canContinue: true,
        timing: elapsed,
        status: 'timeout'
      });
    }
    
    const elapsed = Date.now() - startTime;
    
    const registrationRecord = {
      registrationId: firestoreResult.registrationId,
      timestamp: new Date().toISOString(),
      order: {
        orderNumber: deliveryData.order.orderNumber,
        email: deliveryData.order.email,
        items: deliveryData.order.items,
        total: deliveryData.order.total
      },
      roblox: {
        username: deliveryData.roblox.username,
        userId: deliveryData.roblox.userId
      },
      status: 'pending_delivery',
      savedToFirestore: true,
      firestoreId: firestoreResult.firestoreId,
      docPath: firestoreResult.docPath,
      timing: elapsed
    };
    
    return res.status(200).json({
      success: true,
      message: 'Delivery request registered successfully in Firestore',
      registrationId: registrationRecord.registrationId,
      data: registrationRecord
    });
    
  } catch (error) {
    const elapsed = Date.now() - startTime;
    console.error('‚ùå Delivery registration failed:', error);
    
    return res.status(500).json({ 
      error: 'Failed to save delivery request to Firestore',
      message: error.message,
      timing: elapsed,
      canContinue: true // Let user continue to server anyway
    });
  }
}

// ROBLOX USERNAME VERIFICATION (unchanged)
async function handleUsernameVerification(req, res, username) {
  console.log(`üéÆ Roblox Username Verification: ${username}`);
  
  if (!username || typeof username !== 'string' || username.trim() === '') {
    return res.status(400).json({ error: 'Username is required' });
  }

  const cleanUsername = username.trim();
  
  if (cleanUsername.length < 3 || cleanUsername.length > 20) {
    return res.status(400).json({ error: 'Username must be between 3-20 characters' });
  }

  if (!/^[a-zA-Z0-9_]+$/.test(cleanUsername)) {
    return res.status(400).json({ error: 'Username can only contain letters, numbers, and underscores' });
  }

  console.log(`Searching for Roblox user: ${cleanUsername}`);

  // Method 1: Username-to-ID conversion
  try {
    console.log('Attempting username-to-ID conversion...');
    const usernameToIdResponse = await fetch('https://users.roblox.com/v1/usernames/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        usernames: [cleanUsername],
        excludeBannedUsers: true
      })
    });
    
    if (usernameToIdResponse.ok) {
      const usernameData = await usernameToIdResponse.json();
      
      if (usernameData.data && usernameData.data.length > 0) {
        const userData = usernameData.data[0];
        
        if (userData.name && userData.name.toLowerCase() === cleanUsername.toLowerCase()) {
          console.log('‚úÖ Found exact match via username-to-ID API:', userData.name);
          
          let avatarUrl = `https://www.roblox.com/headshot-thumbnail/image?userId=${userData.id}&width=150&height=150&format=png&v=${Date.now()}`;
          
          try {
            const avatarResponse = await fetch(`https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=${userData.id}&size=150x150&format=Png&isCircular=false`);
            if (avatarResponse.ok) {
              const avatarData = await avatarResponse.json();
              if (avatarData.data && avatarData.data[0] && avatarData.data[0].imageUrl) {
                avatarUrl = avatarData.data[0].imageUrl;
              }
            }
          } catch (avatarError) {
            console.log('Avatar API failed, using fallback URL');
          }

          return res.status(200).json({
            success: true,
            userId: userData.id.toString(),
            username: userData.name,
            avatarUrl: avatarUrl,
            verified: true,
            source: 'roblox_api'
          });
        }
      }
    }
  } catch (apiError) {
    console.error('‚ùå Username-to-ID API error:', apiError.message);
  }

  // Method 2: Fallback to search API
  try {
    console.log('Falling back to search API...');
    const userSearchResponse = await fetch(`https://users.roblox.com/v1/users/search?keyword=${encodeURIComponent(cleanUsername)}&limit=10`);
    
    if (userSearchResponse.ok) {
      const userSearchData = await userSearchResponse.json();
      
      if (userSearchData.data && userSearchData.data.length > 0) {
        const exactMatch = userSearchData.data.find(user => 
          user.name && user.name.toLowerCase() === cleanUsername.toLowerCase()
        );
        
        if (exactMatch) {
          console.log('‚úÖ Found exact match via search API:', exactMatch.name);
          
          let avatarUrl = `https://www.roblox.com/headshot-thumbnail/image?userId=${exactMatch.id}&width=150&height=150&format=png&v=${Date.now()}`;
          
          try {
            const avatarResponse = await fetch(`https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=${exactMatch.id}&size=150x150&format=Png&isCircular=false`);
            if (avatarResponse.ok) {
              const avatarData = await avatarResponse.json();
              if (avatarData.data && avatarData.data[0] && avatarData.data[0].imageUrl) {
                avatarUrl = avatarData.data[0].imageUrl;
              }
            }
          } catch (avatarError) {
            console.log('Avatar API failed, using fallback URL');
          }

          return res.status(200).json({
            success: true,
            userId: exactMatch.id.toString(),
            username: exactMatch.name,
            avatarUrl: avatarUrl,
            verified: true,
            source: 'roblox_api'
          });
        }
      }
    }
  } catch (apiError) {
    console.error('‚ùå Search API error:', apiError.message);
  }

  console.log('‚ùå Username verification failed with both methods');
  return res.status(404).json({ 
    error: `User "${cleanUsername}" not found`,
    details: 'Please check the spelling and try again (case-sensitive)'
  });
}

// VALIDATION FUNCTIONS (unchanged)
function validateOrderForDelivery(order) {
  if (order.financial_status !== 'paid' && order.financial_status !== 'partially_paid') {
    return {
      valid: false,
      reason: 'Order payment not confirmed',
      details: 'Please ensure your payment has been processed before requesting delivery'
    };
  }

  if (order.cancelled_at) {
    return {
      valid: false,
      reason: 'Order has been cancelled',
      details: 'Cancelled orders are not eligible for delivery'
    };
  }

  if (order.fulfillment_status === 'fulfilled') {
    return {
      valid: false,
      reason: 'Order has already been fulfilled',
      details: 'This order has already been delivered and cannot be claimed again'
    };
  }

  if (order.financial_status === 'refunded' || order.financial_status === 'partially_refunded') {
    return {
      valid: false,
      reason: 'Order has been refunded',
      details: 'Refunded orders are not eligible for delivery'
    };
  }

  if (order.refunds && order.refunds.length > 0) {
    const totalRefunded = order.refunds.reduce((sum, refund) => {
      return sum + parseFloat(refund.amount || 0);
    }, 0);
    
    const totalPrice = parseFloat(order.total_price || 0);
    
    if (totalRefunded >= totalPrice) {
      return {
        valid: false,
        reason: 'Order has been fully refunded',
        details: 'Fully refunded orders are not eligible for delivery'
      };
    }
  }

  return { valid: true };
}

function formatOrderItems(lineItems) {
  if (!lineItems || lineItems.length === 0) {
    return 'Digital Items';
  }
  
  return lineItems.map(item => {
    let itemName = item.title;
    if (item.variant_title && item.variant_title !== 'Default Title') {
      itemName += ` (${item.variant_title})`;
    }
    if (item.quantity > 1) {
      itemName += ` x${item.quantity}`;
    }
    return itemName;
  }).join(', ');
}

// UTILITY FUNCTIONS
function generateDeliveryId() {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substr(2, 6).toUpperCase();
  return `AG_${timestamp}_${random}`;
}

// MAIN HANDLER
export default async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  const startTime = Date.now();

  try {
    const { orderNumber, email, username, action, deliveryData } = req.body;
    
    console.log('üîç API Request:', { 
      orderNumber: !!orderNumber, 
      email: !!email, 
      username: !!username, 
      action: action || 'none',
      hasDeliveryData: !!deliveryData
    });

    // Debug Shopify connection
    if (action === 'debug_shopify') {
      try {
        const debugResults = await debugShopifyConnection();
        return res.status(200).json({
          success: true,
          debug: debugResults
        });
      } catch (error) {
        return res.status(500).json({ 
          success: false,
          error: error.message,
          stack: DEBUG_MODE ? error.stack : undefined
        });
      }
    }

    // Firestore test
    if (action === 'test_firestore') {
      try {
        const db = initFirebase();
        const testDoc = {
          test: true,
          timestamp: serverTimestamp(),
          message: 'Firestore connection test',
          testId: generateDeliveryId(),
          createdAt: new Date().toISOString()
        };
        
        const testRef = await addDoc(collection(db, 'connection_tests'), testDoc);
        const elapsed = Date.now() - startTime;
        
        return res.status(200).json({
          success: true,
          message: 'Firestore connection successful',
          testDocId: testRef.id,
          timing: elapsed
        });
        
      } catch (error) {
        return res.status(500).json({ 
          success: false,
          error: error.message
        });
      }
    }

    // Route requests
    if (action === 'verify_order' && orderNumber && email) {
      return await handleOrderVerification(req, res, orderNumber, email);
    }
    
    if (action === 'verify_username' && username) {
      return await handleUsernameVerification(req, res, username);
    }

    if (action === 'register_delivery' && deliveryData) {
      return await handleDeliveryRegistration(req, res, deliveryData);
    }

    // Fallback detection
    if (orderNumber && email && !username) {
      return await handleOrderVerification(req, res, orderNumber, email);
    }
    
    if (username && !orderNumber && !email) {
      return await handleUsernameVerification(req, res, username);
    }

    return res.status(400).json({ 
      error: 'Invalid request parameters',
      received: { orderNumber: !!orderNumber, email: !!email, username: !!username, action, hasDeliveryData: !!deliveryData },
      expected: 'Either (orderNumber + email) for order verification, (username) for Roblox verification, or (deliveryData) for delivery registration'
    });

  } catch (error) {
    const elapsed = Date.now() - startTime;
    console.error('üí• API error:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      message: error.message,
      timing: elapsed
    });
  }
}
